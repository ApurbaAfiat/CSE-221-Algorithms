# -*- coding: utf-8 -*-
"""Task_05.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iU24V-qweUIjvC3gAiHTzsyB6VjGXE_P
"""

from collections import defaultdict, deque

def bfs_shortest_path(graph, start, destination):
    queue = deque([(start, [start])])
    visited = set()

    while queue:
        current, path = queue.popleft()

        if current == destination:
            return len(path) - 1, path

        visited.add(current)

        for neighbor in graph[current]:
            if neighbor not in visited:
                queue.append((neighbor, path + [neighbor]))

    return float('inf'), []
with open("/content/Input5.txt", "r") as file:
    N, M, D = map(int, file.readline().split())
    adjacency_list = defaultdict(list)

    for _ in range(M):
        edge = file.readline().split()
        ui = int(edge[0])
        vi = int(edge[1])
        adjacency_list[ui].append(vi)
        adjacency_list[vi].append(ui)
time, shortest_path = bfs_shortest_path(adjacency_list, 1, D)
print("Time:", time)
print("Shortest Path:", " ".join(str(city) for city in shortest_path))

with open("/content/Output5.txt", "r") as output_file:
    expected_time, expected_path = output_file.readlines()