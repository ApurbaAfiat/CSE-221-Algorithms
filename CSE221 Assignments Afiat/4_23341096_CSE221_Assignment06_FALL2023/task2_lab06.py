# -*- coding: utf-8 -*-
"""Task2_LAB06.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q0XaAgVOA0z8k4uk4rAaQsTsnkFYH7rI
"""

import heapq

def dijkstra(graph, start):
    n = len(graph)
    distances = [float('inf')] * n
    distances[start] = 0
    heap = [(0, start)]

    while heap:
        dist, node = heapq.heappop(heap)
        if dist > distances[node]:
            continue

        for neighbor, weight in graph[node]:
            new_dist = dist + weight
            if new_dist < distances[neighbor]:
                distances[neighbor] = new_dist
                heapq.heappush(heap, (new_dist, neighbor))

    return distances
with open('/content/Input2.txt', 'r') as f:
    N, M = map(int, f.readline().split())
    graph = [[] for _ in range(N)]

    for _ in range(M):
        u, v, w = map(int, f.readline().split())
        graph[u - 1].append((v - 1, w))

    S, T = map(int, f.readline().split())

# Calculate distances
source_distances = dijkstra(graph, S - 1)
target_distances = dijkstra(graph, T - 1)

# Finding the meeting point
min_time = float('inf')
meeting_node = -1
for node in range(N):
    if source_distances[node] + target_distances[node] < min_time:
        min_time = source_distances[node] + target_distances[node]
        meeting_node = node
with open('/content/Output2.txt', 'w') as f:
    if min_time == float('inf'):
        f.write("Impossible\n")
    else:
        f.write("Time " + str(min_time) + "\n")
        f.write("Node " + str(meeting_node + 1) + "\n")